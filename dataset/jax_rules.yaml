schema_version: "3.0"
description: "Complete JAX LAX Unary and Binary Operator Definition for Automated Testing"

# ==============================================================================
# 0. 全局定义 (Global Definitions)
# ==============================================================================
definitions:

  # --- 生成策略模板 (Generation Strategies) ---
  strategies:
    # A. 通用策略
    uniform_std: &strat_std
      strategy: uniform
      range: [-10.0, 10.0]

    normal_std: &strat_normal
      strategy: normal
      mean: 0.0
      std: 1.0

    int_scalar: &strat_int_scalar
      strategy: int
      range: [0, 100]

    float_scalar: &strat_float_scalar
      strategy: float
      range: [-10.0, 10.0]

    uniform_pos: &strat_pos  # (0, 10]
      strategy: uniform
      range: [0.001, 10.0]

    uniform_non_neg: &strat_non_neg # [0, 10]
      strategy: uniform
      range: [0.0, 10.0]

    # B. 特殊定义域策略
    # 用于 acos, asin, atanh (-1, 1)
    unit_interval: &strat_unit
      strategy: uniform
      range: [-0.99, 0.99]

    # 用于 acosh (>= 1)
    large_pos: &strat_large_pos
      strategy: uniform
      range: [1.01, 100.0]

    # 用于除法分母 (排除 0)
    non_zero: &strat_nonzero
      strategy: uniform
      range: [-10.0, 10.0]
      exclude_values: [0.0, -0.0]

    # 用于概率类 (0, 1)
    probability: &strat_prob
      strategy: uniform
      range: [0.01, 0.99]

# ----------------------------------------------------------------------------
# 1.1 Elementwise()
# ----------------------------------------------------------------------------
elementwise:
  - { op_name: jax.lax.ceil,       input: [x],   generation: {x: *strat_std} }
  - { op_name: jax.lax.floor,      input: [x],   generation: {x: *strat_std} }
  - { op_name: jax.lax.round,      input: [x],   generation: {x: *strat_std} }
  - { op_name: jax.lax.square,     input: [x],   generation: {x: *strat_normal} }

  - op_name: jax.lax.reciprocal
    input: [x]
    generation: {x: *strat_nonzero}

  - op_name: jax.lax.sqrt
    input: [x]
    generation: {x: *strat_non_neg}

  - op_name: jax.lax.rsqrt
    input: [x]
    generation: {x: *strat_pos}

  - { op_name: jax.lax.exp,      input: [x], generation: {x: *strat_normal} }
  - { op_name: jax.lax.exp2,     input: [x], generation: {x: *strat_normal} }
  - { op_name: jax.lax.expm1,    input: [x], generation: {x: *strat_normal} }
  - { op_name: jax.lax.logistic, input: [x], generation: {x: *strat_normal} }

  - { op_name: jax.lax.log,      input: [x], generation: {x: *strat_pos} }
  - { op_name: jax.lax.log1p,    input: [x], generation: {x: {strategy: uniform, range: [-0.9, 10.0]}} }

  - { op_name: jax.lax.sin,  input: [x], generation: {x: *strat_std} }
  - { op_name: jax.lax.cos,  input: [x], generation: {x: *strat_std} }
  - { op_name: jax.lax.tan,  input: [x], generation: {x: *strat_normal} }

  - { op_name: jax.lax.asin,  input: [x], generation: {x: *strat_unit} }
  - { op_name: jax.lax.acos,  input: [x], generation: {x: *strat_unit} }
  - { op_name: jax.lax.atan, input: [x], generation: {x: *strat_normal} }

  - { op_name: jax.lax.sinh, input: [x], generation: {x: *strat_normal} }
  - { op_name: jax.lax.cosh, input: [x], generation: {x: *strat_normal} }
  - { op_name: jax.lax.tanh, input: [x], generation: {x: *strat_normal} }
  - { op_name: jax.lax.asinh, input: [x], generation: {x: *strat_normal} }
  - { op_name: jax.lax.acosh, input: [x], generation: {x: *strat_large_pos} }
  - { op_name: jax.lax.atanh, input: [x], generation: {x: *strat_unit} }

  - { op_name: jax.lax.bessel_i0e, input: [x], generation: {x: *strat_normal} }
  - { op_name: jax.lax.bessel_i1e, input: [x], generation: {x: *strat_normal} }
  - { op_name: jax.lax.erf,        input: [x], generation: {x: *strat_normal} }
  - { op_name: jax.lax.erfc,       input: [x], generation: {x: *strat_normal} }
  - { op_name: jax.lax.erf_inv,    input: [x], generation: {x: *strat_unit} }
  - { op_name: jax.lax.lgamma,     input: [x], generation: {x: *strat_pos} }
  - { op_name: jax.lax.digamma,    input: [x], generation: {x: *strat_pos} }

  - { op_name: jax.lax.add, input: [x, y], generation: {x: *strat_normal, y: *strat_normal} }
  - { op_name: jax.lax.sub, input: [x, y], generation: {x: *strat_normal, y: *strat_normal} }
  - { op_name: jax.lax.mul, input: [x, y], generation: {x: *strat_normal, y: *strat_normal} }
  - { op_name: jax.lax.max, input: [x, y], generation: {x: *strat_normal, y: *strat_normal} }
  - { op_name: jax.lax.min, input: [x, y], generation: {x: *strat_normal, y: *strat_normal} }

  - op_name: jax.lax.div
    input: [x, y]
    generation: {x: *strat_normal, y: *strat_nonzero}

  - op_name: jax.lax.rem
    input: [x, y]
    generation: {x: *strat_normal, y: *strat_nonzero}

  - op_name: jax.lax.pow
    input: [x, y]
    generation: {x: *strat_pos, y: *strat_normal}

  - op_name: jax.lax.integer_pow
    input: [x, y]
    generation:
      x: *strat_normal
      y: *strat_int_scalar

  - op_name: jax.lax.atan2
    input: [x, y]
    generation: {x: *strat_std, y: *strat_std}

  - op_name: jax.lax.nextafter
    input: [x1, x2]
    generation: {x1: *strat_std, x2: *strat_std}

  - op_name: jax.lax.zeta
    input: [x, q]
    generation: {x: *strat_large_pos, q: *strat_pos}

  - op_name: jax.lax.polygamma
    input: [m, x]
    generation:
      m:
        <<: *strat_int_scalar
        range: [1,5]
      x: *strat_std

  - { op_name: jax.lax.abs, input: [x], generation: {x: *strat_std} }

  - op_name: jax.lax.clamp
    input: [x, min, max]
    generation:
      x: *strat_std
      min:
        <<: *strat_float_scalar
        range: [-10.0, -0.1]
      max:
        <<: *strat_float_scalar
        range: [0.1, 10.0]

  - { op_name: jax.lax.complex, input: [x, y], generation: {x: *strat_normal, y: *strat_normal} }
  - { op_name: jax.lax.conj, input: [x], generation: {x: *strat_normal} }

  - { op_name: jax.lax.eq, input: [x, y], generation: {x: *strat_normal, y: *strat_normal} }
  - { op_name: jax.lax.ge, input: [x, y], generation: {x: *strat_normal, y: *strat_normal} }
  - { op_name: jax.lax.gt, input: [x, y], generation: {x: *strat_normal, y: *strat_normal} }

  - op_name: jax.lax.igamma
    input: [a, x]
    generation: {a: *strat_pos, x: *strat_pos}

  - op_name: jax.lax.igammac
    input: [a, x]
    generation: {a: *strat_pos, x: *strat_pos}

  - { op_name: jax.lax.is_finite, input: [x], generation: {x: *strat_std} }
  - { op_name: jax.lax.le, input: [x, y], generation: {x: *strat_normal, y: *strat_normal} }
  - { op_name: jax.lax.lt, input: [x, y], generation: {x: *strat_normal, y: *strat_normal} }
  - { op_name: jax.lax.ne, input: [x, y], generation: {x: *strat_normal, y: *strat_normal} }
  - { op_name: jax.lax.neg, input: [x], generation: {x: *strat_normal} }
  - { op_name: jax.lax.shift_left, input: [x, y], generation: {x: *strat_int_scalar, y: *strat_int_scalar} }
  - { op_name: jax.lax.shift_right_arithmetic, input: [x, y], generation: {x: *strat_int_scalar, y: *strat_int_scalar} }
  - { op_name: jax.lax.sign, input: [x], generation: {x: *strat_normal} }

# ----------------------------------------------------------------------------
# 1.2 Reduction / Linalg / Array / Other
# ----------------------------------------------------------------------------
reduction:
  - op_name: jax.lax.argmax
    input: [operand, axis, index_dtype]
    generation:
      operand: *strat_normal
      axis:
        strategy: axis
        from_input: operand
      index_dtype: *strat_int_scalar
  - op_name: jax.lax.argmin
    input: [operand, axis, index_dtype]
    generation:
      operand: *strat_normal
      axis:
        strategy: axis
        from_input: operand
      index_dtype: *strat_int_scalar

  - op_name: jax.lax.cumlogsumexp
    input: [operand, axis]
    generation:
      operand: *strat_normal
      axis:
        strategy: axis
        from_input: operand
  - op_name: jax.lax.cummax
    input: [operand, axis]
    generation:
      operand: *strat_normal
      axis:
        strategy: axis
        from_input: operand
  - op_name: jax.lax.cummin
    input: [operand, axis]
    generation:
      operand: *strat_normal
      axis:
        strategy: axis
        from_input: operand
  - op_name: jax.lax.cumprod
    input: [operand, axis]
    generation:
      operand: *strat_normal
      axis:
        strategy: axis
        from_input: operand
  - op_name: jax.lax.cumsum
    input: [operand, axis]
    generation:
      operand: *strat_normal
      axis:
        strategy: axis
        from_input: operand

  - op_name: jax.lax.reduce_max
    input: [operand, axes]
    generation:
      operand: *strat_normal
      axes:
        strategy: axes_tuple
        min_len: 1
        sorted: true
  - op_name: jax.lax.reduce_min
    input: [operand, axes]
    generation:
      operand: *strat_normal
      axes:
        strategy: axes_tuple
        min_len: 1
        sorted: true
  - op_name: jax.lax.reduce_sum
    input: [operand, axes]
    generation:
      operand: *strat_normal
      axes:
        strategy: axes_tuple
        min_len: 1
        sorted: true
  - op_name: jax.lax.reduce_prod
    input: [operand, axes]
    generation:
      operand: *strat_normal
      axes:
        strategy: axes_tuple
        min_len: 1
        sorted: true
  - op_name: jax.lax.top_k
    input: [operand, k]
    generation:
      operand: *strat_normal
      k:
        <<: *strat_int_scalar
        range: [1,1]

linalg:
  - op_name: jax.lax.linalg.cholesky
    input: [x]
    generation:
      x:
        strategy: spd_matrix
        eps: 1e-3

  - op_name: jax.lax.linalg.eig
    input: [x]
    generation:
      x:
        strategy: square_normal

  - op_name: jax.lax.linalg.eigh
    input: [x]
    generation:
      x:
        strategy: symmetric_matrix

  - op_name: jax.lax.linalg.householder_product
    input: [a, taus]
    generation:
      a: *strat_normal
      taus:
        strategy: taus_from_input
        from_input: a

  - op_name: jax.lax.linalg.lu
    input: [x]
    generation:
      x:
        strategy: square_normal

  - op_name: jax.lax.linalg.qr
    input: [x]
    generation:
      x: *strat_normal

  - op_name: jax.lax.linalg.svd
    input: [x]
    generation:
      x: *strat_normal

  - op_name: jax.lax.linalg.triangular_solve
    input: [a, b]
    generation:
      a:
        strategy: triangular_matrix
        upper: true
      b:
        strategy: rhs_from_input
        from_input: a
array: []
other:
  - op_name: jax.lax.sort
    input: [operand]
    generation: {operand: *strat_normal}
  - op_name: jax.lax.dot
    input: [lhs, rhs]
    generation: {lhs: *strat_normal, rhs: *strat_normal}
    shape_policy:
      name: matmul_compatible
      fuzz: true
