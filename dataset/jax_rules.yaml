schema_version: "3.0"
description: "Complete JAX LAX Unary and Binary Operator Definition for Automated Testing"

# ==============================================================================
# 0. 全局定义 (Global Definitions)
# ==============================================================================
definitions:

  # --- 生成策略模板 (Generation Strategies) ---
  strategies:
    # A. 通用策略
    uniform_std: &strat_std
      strategy: uniform
      range: [-10.0, 10.0]

    normal_std: &strat_normal
      strategy: normal
      mean: 0.0
      std: 1.0

    int_scalar: &strat_int_scalar
      strategy: int
      range: [0, 100]

    float_scalar: &strat_float_scalar
      strategy: float
      range: [-10.0, 10.0]

    uniform_pos: &strat_pos  # (0, 10]
      strategy: uniform
      range: [0.001, 10.0]

    uniform_non_neg: &strat_non_neg # [0, 10]
      strategy: uniform
      range: [0.0, 10.0]

    # B. 特殊定义域策略
    # 用于 acos, asin, atanh (-1, 1)
    unit_interval: &strat_unit
      strategy: uniform
      range: [-0.99, 0.99]

    # 用于 acosh (>= 1)
    large_pos: &strat_large_pos
      strategy: uniform
      range: [1.01, 100.0]

    # 用于除法分母 (排除 0)
    non_zero: &strat_nonzero
      strategy: uniform
      range: [-10.0, 10.0]
      exclude_values: [0.0, -0.0]

    # 用于概率类 (0, 1)
    probability: &strat_prob
      strategy: uniform
      range: [0.01, 0.99]

# ----------------------------------------------------------------------------
# 1.1 Elementwise()
# ----------------------------------------------------------------------------
elementwise:
  - { op_name: jax.lax.ceil,       input: [x],   generation: {x: *strat_std} }
  - { op_name: jax.lax.floor,      input: [x],   generation: {x: *strat_std} }
  - { op_name: jax.lax.round,      input: [x],   generation: {x: *strat_std} }
  - { op_name: jax.lax.square,     input: [x],   generation: {x: *strat_normal} }

  - op_name: jax.lax.reciprocal
    input: [x]
    generation: {x: *strat_nonzero}

  - op_name: jax.lax.sqrt
    input: [x]
    generation: {x: *strat_non_neg}

  - op_name: jax.lax.rsqrt
    input: [x]
    generation: {x: *strat_pos}

  - { op_name: jax.lax.exp,      input: [x], generation: {x: *strat_normal} }
  - { op_name: jax.lax.exp2,     input: [x], generation: {x: *strat_normal} }
  - { op_name: jax.lax.expm1,    input: [x], generation: {x: *strat_normal} }
  - { op_name: jax.lax.logistic, input: [x], generation: {x: *strat_normal} }

  - { op_name: jax.lax.log,      input: [x], generation: {x: *strat_pos} }
  - { op_name: jax.lax.log1p,    input: [x], generation: {x: {strategy: uniform, range: [-0.9, 10.0]}} }

  - { op_name: jax.lax.sin,  input: [x], generation: {x: *strat_std} }
  - { op_name: jax.lax.cos,  input: [x], generation: {x: *strat_std} }
  - { op_name: jax.lax.tan,  input: [x], generation: {x: *strat_normal} }

  - { op_name: jax.lax.asin,  input: [x], generation: {x: *strat_unit} }
  - { op_name: jax.lax.acos,  input: [x], generation: {x: *strat_unit} }
  - { op_name: jax.lax.atan, input: [x], generation: {x: *strat_normal} }

  - { op_name: jax.lax.sinh, input: [x], generation: {x: *strat_normal} }
  - { op_name: jax.lax.cosh, input: [x], generation: {x: *strat_normal} }
  - { op_name: jax.lax.tanh, input: [x], generation: {x: *strat_normal} }
  - { op_name: jax.lax.asinh, input: [x], generation: {x: *strat_normal} }
  - { op_name: jax.lax.acosh, input: [x], generation: {x: *strat_large_pos} }
  - { op_name: jax.lax.atanh, input: [x], generation: {x: *strat_unit} }

  - { op_name: jax.lax.bessel_i0e, input: [x], generation: {x: *strat_normal} }
  - { op_name: jax.lax.bessel_i1e, input: [x], generation: {x: *strat_normal} }
  - { op_name: jax.lax.erf,        input: [x], generation: {x: *strat_normal} }
  - { op_name: jax.lax.erfc,       input: [x], generation: {x: *strat_normal} }
  - { op_name: jax.lax.erf_inv,    input: [x], generation: {x: *strat_unit} }
  - { op_name: jax.lax.lgamma,     input: [x], generation: {x: *strat_pos} }
  - { op_name: jax.lax.digamma,    input: [x], generation: {x: *strat_pos} }

  - { op_name: jax.lax.add, input: [x, y], generation: {x: *strat_normal, y: *strat_normal} }
  - { op_name: jax.lax.sub, input: [x, y], generation: {x: *strat_normal, y: *strat_normal} }
  - { op_name: jax.lax.mul, input: [x, y], generation: {x: *strat_normal, y: *strat_normal} }
  - { op_name: jax.lax.max, input: [x, y], generation: {x: *strat_normal, y: *strat_normal} }
  - { op_name: jax.lax.min, input: [x, y], generation: {x: *strat_normal, y: *strat_normal} }

  - op_name: jax.lax.div
    input: [x, y]
    generation: {x: *strat_normal, y: *strat_nonzero}

  - op_name: jax.lax.rem
    input: [x, y]
    generation: {x: *strat_normal, y: *strat_nonzero}

  - op_name: jax.lax.pow
    input: [x, y]
    generation: {x: *strat_pos, y: *strat_normal}

  - op_name: jax.lax.integer_pow
    input: [x, y]
    generation:
      x: *strat_normal
      y: *strat_int_scalar

  - op_name: jax.lax.atan2
    input: [x, y]
    generation: {x: *strat_std, y: *strat_std}

  - op_name: jax.lax.nextafter
    input: [x1, x2]
    generation: {x1: *strat_std, x2: *strat_std}

  - op_name: jax.lax.zeta
    input: [x, q]
    generation: {x: *strat_large_pos, q: *strat_pos}

  - op_name: jax.lax.polygamma
    input: [m, x]
    generation:
      m:
        <<: *strat_int_scalar
        range: [1,5]
      x: *strat_std

  - { op_name: jax.lax.abs, input: [x], generation: {x: *strat_std} }

  - op_name: jax.lax.clamp
    input: [x, min, max]
    generation:
      x: *strat_std
      min:
        <<: *strat_float_scalar
        range: [-10.0, -0.1]
      max:
        <<: *strat_float_scalar
        range: [0.1, 10.0]

  - { op_name: jax.lax.complex, input: [x, y], generation: {x: *strat_normal, y: *strat_normal} }
  - { op_name: jax.lax.conj, input: [x], generation: {x: *strat_normal} }

  - { op_name: jax.lax.eq, input: [x, y], generation: {x: *strat_normal, y: *strat_normal} }
  - { op_name: jax.lax.ge, input: [x, y], generation: {x: *strat_normal, y: *strat_normal} }
  - { op_name: jax.lax.gt, input: [x, y], generation: {x: *strat_normal, y: *strat_normal} }

  - op_name: jax.lax.igamma
    input: [a, x]
    generation: {a: *strat_pos, x: *strat_pos}

  - op_name: jax.lax.igammac
    input: [a, x]
    generation: {a: *strat_pos, x: *strat_pos}

  - { op_name: jax.lax.is_finite, input: [x], generation: {x: *strat_std} }
  - { op_name: jax.lax.le, input: [x, y], generation: {x: *strat_normal, y: *strat_normal} }
  - { op_name: jax.lax.lt, input: [x, y], generation: {x: *strat_normal, y: *strat_normal} }
  - { op_name: jax.lax.ne, input: [x, y], generation: {x: *strat_normal, y: *strat_normal} }
  - { op_name: jax.lax.neg, input: [x], generation: {x: *strat_normal} }
  - { op_name: jax.lax.shift_left, input: [x, y], generation: {x: *strat_int_scalar, y: *strat_int_scalar} }
  - { op_name: jax.lax.shift_right_arithmetic, input: [x, y], generation: {x: *strat_int_scalar, y: *strat_int_scalar} }
  - { op_name: jax.lax.sign, input: [x], generation: {x: *strat_normal} }

# ----------------------------------------------------------------------------
# 1.2 Reduction / Linalg / Array / Other
# ----------------------------------------------------------------------------
reduction: []
linalg:
  - op_name: jax.lax.argmax
    input: [operand, axis, index_dtype]
    generation:
      operand: *strat_normal
      axis:
        <<: *strat_int_scalar
        range: [0,2]
      index_dtype: *strat_int_scalar
  - op_name: jax.lax.argmin
    input: [operand, axis, index_dtype]
    generation:
      operand: *strat_normal
      axis:
        <<: *strat_int_scalar
        range: [0,2]
      index_dtype: *strat_int_scalar

array: []
other:
  - op_name: jax.lax.sort
    input: [operand]
    generation: {operand: *strat_normal}
  - op_name: jax.lax.dot
    input: [lhs, rhs]
    generation: {lhs: *strat_normal, rhs: *strat_normal}
    shape_policy:
      name: matmul_compatible
      fuzz: true
